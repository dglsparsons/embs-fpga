% Report write up for my third year project at the University of York on 
% Real Time Programming in the D Programming Language.
% By Douglas Parsons

\documentclass[a4paper, 11pt]{article}
%\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
%\usepackage[nottoc,numbib]{tocbibind}
%\usepackage{listings} % for code examples
\usepackage[margin=0.8in]{geometry}
%\usepackage{pdfpages}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


% Sorting out the headers 
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhf{}
\setlength{\headheight}{15.2pt}

% Settings for code examples
%\usepackage{color}
%\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
%\definecolor{greencomments}{rgb}{0,0.5,0}
%\definecolor{redstrings}{rgb}{0.9,0,0}
%\lstset{language=C,
%showstringspaces=false,
%commentstyle=\color{greencomments},
%keywordstyle=\color{bluekeywords}\bfseries,
%stringstyle=\color{redstrings},
%basicstyle=\ttfamily
%}

\title{EMBS Summer Term Open Assessment 2016 Written Report}
\author{Exam Candidate Number: Y1461429}
\date{\today}

% For forcing float draw after tables
%\usepackage{placeins}

%Your report should discuss key problem analysis, design, implementation,
%evaluation and testing activities. This should include discussion of:
%– architectural choices and their effectiveness;
%– acceleration strategy adopted, including its effectiveness.

\begin{document}
\maketitle
%\section*{Abstract}
%\tableofcontents
\section{Problem Analysis} %100 words
For this open-assessment, the problem was to use an FPGA to solve an NP-hard 
problem: the travelling salesman problem. The solution must interact with a user 
via serial to receive a world size and world-id. It will then
request and download a world via ethernet, identify the shortest path around the 
waypoints in this world, avoiding any walls, and finally display and verify the solution. 
\par\bigskip\noindent
This problem can be divided into three main sections: interactions with VGA, ethernet
and the user; creation of a matrix containing distances between each pair of waypoints;
and determining the shortest distance in which every waypoint can be visited.

\section{Design} % 100 words
For the design of the solution, two hardware components were used: the Microblaze, 
which handles interactions with VGA, the user and ethernet, 
and a custom piece of hardware for solving the travelling salesman problem, and 
calculating shortest distances using the A* algorithm. The use of special purpose 
hardware allows many parts of the solution to be pipelined, or run in parallel. 
As a result, this provides a large increase in speed over a purely software approach 
for both the A*, and the travelling salesman problem. The remainder of the software 
was chosen to run on the Microblaze as it is not computationally expensive. 
While running this code on hardware could improve the speed, for example, by 
providing an entire VGA buffer at once, it is not the limiting factor for the 
given problem.

\section{Implementation} % 200 words
% A*
% Storing 60 x 60 grid, 2 bits for state, 2 bits for direction of parent.
In order to execute the A* in a reasonable amount of time, it was decided that
the A* algorithm should be run on custom hardware, generated through vivado-hls. 
First, the relevant section of the replyworld packet is sent directly to the
hardware. This prevents any overhead of unpacking the data, and repacking for
communicating on the AXI streams. 
\par\bigskip\noindent
In order to calculate the shortest path distances between each pair of
waypoints, an A* algorithm is used. However, rather than maintaining the notion of a
closed list, and an open list, the entire world is stored in a 60 x 60 array.
This enables both the current state of each coordinate, as well as the direction of
its parent to be stored. However, it provides an inefficiency in finding the
lowest cost node that is open: every node in the 60x60 array must be searched
through. This additional overhead is partially offset by including a bound on 
the current explored nodes: a minimum and maximum x and y coordinate limits the
search to only the expanded section of the grid. 
This A* search is initially run $\frac{n^2}{2}$ times to populate a distance
matrix. This contains a value for the distance between each pair of
coordinates, ignoring any walls. 
\par\bigskip\noindent
Once the distance matrix has been established, a brute force algorithm
determines the optimal order to visit each waypoint. This works by using the
popular iterative algorithm, quickperm, to generate each of the $11!$ possible orderings of
nodes \cite{quickperm}. 


% Uses quickperm algorithm to test each possible combination. 

\section{Acceleration Strategy} % 200 words
In order to speed up the solution, 3 improvements were made upon the original design. 
First, as the original A* algorithm was calculating the cost of each node by 
counting the number of parents until the start waypoint was reached, a significant 
speedup was attained by instead keeping track of the cost associated with each 
coordinate. This comes at the cost of increased memory usage, as each cost must 
be stored. As there are 3600 coordinates in a large grid, this is a significant 
amount of additional memory. 
\par\bigskip\noindent
Secondly, while performing the quickperm algorithm, redundant permutations were being 
generated. This occurs as distances between waypoints are the same in both directions: 
for example, path A--B--C has the same cost as path C--B--A. As a result, these 
duplicate results can be removed, significantly reducing the amount of permutations 
needed. This results in a significant reduction in work: rather than the original 
$11!$ permutations needed for a large world, there are therefore only
$\frac{11!}{2}$. 
Furthermore, this improves the speed of the brute force approach for all sizes of 
world. This is implemented in practice by generating $10!$ permutations rather than
$11!$, and, for each permutation generated, creating $6$ variants by treating the 
first half of the array as having an extra element. This is illustrated by the
following diagram: 
%TODO - UML? OF THE N!/2 INSERTION. 
This highlights how the majority of reverse permutations are removed from the
generated result. 
\par\bigskip\noindent
Finally, the third improvement was made by considering the parallel capabilities 
of hardware. Unlike in software, it is possible to perform multiple operations at 
the same time. Therefore, in order to speed up the brute force process, 
two variations of the quickperm algorithm run in parallel for large worlds. 
As the size of the world is known, the array being 
permuted, \texttt{a}, and the permutation counting array, \texttt{p}, has a known 
mid-point that can be predetermined. By creating a second copy of the 
\texttt{brute\_force\_tsp} function, and ensuring the two share no data, the calls 
to both occur in parallel. This is verified by checking the analysis tab of 
vivado\_hls:  \\
\includegraphics[width=\textwidth]{vivado_hls}
This highlights two iterative permutation algorithms occurring in parallel, providing 
a significant speedup in determining the optimal permutation. 

\section{Evaluation and Testing} % 200 words

\section{Conclusions} % 100 words
\bibliographystyle{IEEEtran}
\bibliography{references}
\end{document}
